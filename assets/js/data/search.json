[ { "title": "more const", "url": "/posts/c++-more-const/", "categories": "C++", "tags": "const, c++", "date": "2022-08-22 00:00:00 -0700", "snippet": "As I was trying to understand myself due to multiple ways a const might exist in code, I have found one neat little tip I found regarding const that helps us identify what that const means. I found that out through this website The C++ ‘const’ Declaration: Why &amp; How. The key setence I want to highlight is:Basically ‘const’ applies to whatever is on its immediate left (other than if there is nothing there in which case it applies to whatever is its immediate right).So for example, very simply:const int i;Nothing on the left, so i is a constant integer. The most basic const of all.const int * i;Nothing on the left, so i is a variable pointer to a constant integer.int const * i;i is the same as above since const refers to the “thing” to its left.int * const i;The left of const is *, so this means this is a constant pointer to an integer variable.int const * const i;There are two const here each with something to its left. i is a constant pointer to a constant integer.Those are some basic tips and there will be more const stuff as always!" }, { "title": "const in parameters", "url": "/posts/c++-const-parameters/", "categories": "C++", "tags": "const, c++", "date": "2022-06-24 00:00:00 -0700", "snippet": "There is a concept in C++ known as top-level and low-level const.Top-level const indicates that the pointer itself is a const.Low-level const indicates that the pointer is pointing to a const object.When you initialize a variable such as:int i = 0;int *const p1 = &amp;i;This is known as a top-level const as the variable p1 is a const pointer to non-const i variable. You cannot modify the content of i through p1.*p1 = 10;This is allowed as the const pointer itself has not changed. i is now 10.const int ci = 42;This is still a top-level const because you cannot change the variable itself. This is not a pointer.const int *p2 = &amp;ci;This is a low-level const as p2 is a pointer pointing to a const variable ci.Function parameterTaking all that const property into consideration, we must think carefully about how we want our function parameter to indicate. Using a popular idiom for passing string around, here are some examples of how a string can be passed into a function.void foo_will_not_modify (const std::string &amp;x); // const ref - won't modifyvoid bar_will_not_modify (std::string x); // copy - won't modifyvoid baz_will_modify (std::string &amp;x); // reference - can modifyAnother example that uses const to help make the function definition easily readable can be:std::string::size_type find_char(const string&amp; s, char c, string::size_type &amp;occurs);The parameters would indicate that s will not be modified as it’s a const. c is also not modifiable because it’s a copy. occurs is modifiable because it’s a pass by reference without const. So this could suggest to the code reader that the variable being passed in as the occurs parameter could change after executing that function. In this case, the variable will indicate how many occurences of the c character in s string." }, { "title": "Namespace", "url": "/posts/c++-namespace/", "categories": "C++", "tags": "namespace, c++", "date": "2022-02-17 00:00:00 -0800", "snippet": ":: is known as a scope operator in C++.It tells the codes to look at the scope of the left-hand operand for the name of the right-hand operand. For example, std::cout would say that we want to use cout from the namespace std. That specifies the library name std.There are ways around having to specify the library every time we want to use something from there. The safest way is a using declaration. It let us use a name from a namespace without qualifying the name with a namespace:: prefix.#include &lt;iostream&gt;using std::cout;int main(){ cout &lt;&lt; \"hello world\"; // This will work because we have the using declaration cerr &lt;&lt; \"hello world\"; // This will not work because of no declaration return 0;}#include &lt;iostream&gt;using namespace std;int main(){ cout &lt;&lt; \"hello world\" &lt;&lt; endl; // This will work because we have the using declaration cerr &lt;&lt; \"hello world\" &lt;&lt; endl; // This will work because we have the using declaration return 0;}Headers and Namespace DeclarationsIt is a bad idea to include using in a header file because those codes get copied directly through #include. As such, if a header file has a particular using declaration, every cpp file using the header file will be forced to conform." }, { "title": "Advent of Code 2021", "url": "/posts/advent-of-code/", "categories": "Etc", "tags": "aoc", "date": "2021-12-01 00:00:00 -0800", "snippet": "Advent of CodeEver since I’ve known about Advent of Code, I always get pretty excited to do my best tackling it comes December.This year is no different! Even though I may not always finish them due to a variety of reasons,I always feel like I learn a bit with each attempt. This year, I come prepared with some greater understanding in terms of the grid and graph data structure traversal. Hopefully that will come in handy!As always, my humble Advent of Code repository will get periodically updated.Happy saving Santa Claus." }, { "title": "Class inheritance", "url": "/posts/class-inheritance/", "categories": "Python", "tags": "class, oop", "date": "2019-12-28 00:00:00 -0800", "snippet": "Class inheritance is an important subject to understand when it comes to objected oriented programming. It is the basis in which we can code as little as possible yet still have it contain as much information as possible. I want to focus on the initialization aspect of class inheritance and step through it so it becomes more clear.Consider this simple class example at first:class A(): def __init__(self): print('Initialize A')a_obj = A()You will see that the moment a_obj is called, it initialized the class A which will print&gt;&gt;&gt; Initialize ASo far so good!Now we will consider creating a class B that will inherit from class A and go from there.class B(A): def __init__(self): A.__init__(self) print('Initialize B')What is happening here is class B(A) is telling us that this class B is going to inherit from class A. But just that by itself does not do much. Typically, a well written python module would separate class and instance-level stuff by declaring them at the appropriate places. Instance variables, for example, would typically be delcared inside a class object’s __init__ method. Class variables would be declared outside the scope of the __init__ method. As such, you must initiate the class A inside class B in order to be able to use all the stuff that’s initiated inside class A. That is where A.__init_(self) comes in handy.Now, if you step through this:class A(): def __init__(self): print('Initialize A')class B(A): def __init__(self): A.__init__(self) print('Initialize B')b_obj = B()We will step through this process now step-by-step.b_obj = B() #We begin by initiating the class B via b_obj object.class B(A): #b_obj will bring us to class B which inherits from A.def __init__(self): #B.__init__() will be initiated.A.__init__(self) #Now this will initialize class A.def __init__(self): #We enter A.__init__()print('Initialize A') #This print statement will now be executed and exit A.__init__().print('Initialize B') #This print statement will now be executed and exit B.__init__().So ultimately what you will see as a result of the code blocks above is:&gt;&gt;&gt; Initialize A&gt;&gt;&gt; Initialize BAs you can see, A.__init__(self) is key to initializing class A. It also means that you can place that statement not necessarily immediately after B’s __init__ if you so choose." }, { "title": "Lambda madness", "url": "/posts/lambda-madness/", "categories": "Python", "tags": "lambda", "date": "2019-12-15 00:00:00 -0800", "snippet": "A little while back, I have encountered something rather interesting with regards to Python’s lambda.I searched around online and found other people with similar issues such as this one What do (lambda) function closures capture? Using the example posed by the thread starter:adders = [0, 1, 2, 3]for i in [0, 1, 2, 3]: adders[i] = lambda a: i+aprint adders[1](3)So what this is supposed to be doing is replacing the adders list with a little mini lambda function. So what we are expecting should beadders[0] = [0+a]adders[1] = [1+a]adders[2] = [2+a]adders[3] = [3+a]But as the poster have said, that would mean adders[1](3) would mean 1+3=4. However, to everybody’s surprise, it returned a 6, which would indicate that it is actually getting it from adders[3] with a lambda of 3+3=6. It would appear that Python lambda when going through a loop like that, i is referencing the last value of the loop. Since all the variables are using the same name and within the same scope, we need to find a way to break that out. There are two easy way to do that as suggested by posters in the thread.adders = [0,1,2,3]for i in [0,1,2,3]: adders[i]=lambda a,i=i: i+aprint adders[1](3)This method will force the lambda to capture the i as part of its expression. This should separate the scope of i in the lambda expression to itself.adders = [0,1,2,3]for i in [0,1,2,3]: adders[i] = (lambda b: lambda a: b + a)(i)print adders[1](3)This method as well, in its own way, is also separating out the scopes so it’s localized to the lambda expression itself.This is very handy to know because I have had situations where I am procedurally generating buttons for a GUI that triggers procedurally generated function via a loop. Ultimately all the buttons point to the same function, which is the last function in the loop list. That caused a lot of confusion!" }, { "title": "Using python's \"with\" statement", "url": "/posts/the-with-statement/", "categories": "Python", "tags": "with", "date": "2019-05-06 00:00:00 -0700", "snippet": "Recently, I have learned about the usage of with statement in python. It has some pretty interesting properties in the sense that it can be nicely used for contextual purposes. Acting very similarly as a @ decorator, the with is often used to execute codes before and after codes that it wrapped around. Consider this very basic example:class with_statement(object): def __enter__(self): print('Entering!') def __exit__(self, exc_type, exc_val, exc_tb): print('Exiting!')with with_statement(): print('Inbetween string!')So if you were to execute the codes above, here is the result you will see:Entering!Inbetween string!Exiting!As you can see, when you wrapped the Inbetween string! print statement with the with with_statement():, it will execute the __enter__ codes first. Then your wrapped codes, then the __exit__ codes. So the basically idea is that it’ll execute the codes in those specific orders, which can be very powerful. To elaborate a bit more on this, here are some expanded idea on the previous codes that allows it to do a little bit more.class with_statement_two(object): def __init__(self, dictKey): self.dictKey = dictKey def __enter__(self): self.withDict = {} for i in range(0, 5): self.withDict[i] = 'I have %s cat(s)!' % i print('Calculating how many cats I have...') return self.withDict def __exit__(self, exc_type, exc_val, exc_tb): if self.dictKey in self.withDict: print(self.withDict[self.dictKey])with with_statement_two(2): print('Inbetween string!')Calculating how many cats I have...Inbetween string!I have 2 cat(s)!So in this scenario, we can pass a parameter into the with_statement_two class object. With that parameter, you can see that the with_statement_two class object is using that parameter to search a dictionary it created and output a dictionary value accordingly. So in this scenario, a dictionary is created in the __enter__ function, meaning, the moment the with statement is called. Then, using the parameter it recieved upon its initialization of __init__, it searches the dictionary key for a dictionary value with the parameter passed in. In this case, I have 2 cat(s) is the resulting output because an integer of 2 is the parameter being passed through.Another common example of using the with statement is with the native python functionality of opening text documents. So instead of the typing:myFile = open('fileName.txt', 'r')for line in myFile: do somethingYou can re-write it to be like this, which is considered to be a little bit cleaner!with open('fileName.txt', 'r') as myFile: for line in myFile: do something" }, { "title": "The power of partial", "url": "/posts/partial-power/", "categories": "Python", "tags": "oop", "date": "2019-04-09 00:00:00 -0700", "snippet": "A little something that I have learned when making a PySide widget at work is the usage of functools’ partial. My most basic understanding of this is that it helps passes parameters to a function. A basic representation of partial can be seen here:from functools import partialdef add(a, b, c): return a + b + cadd_part = partial(add, c=2, b=1)print(add_part(3))print(add(3, 1, 2))Both using the partial function and the function itself will return 6. So, on the surface, it doesn’t seem all that special or important. However, consider that Qt signals don’t allow for the passing of parameters, partial can be used to circumvent that. Consider this particular Qt signal tutorial. The basic set up of that signal tutorial is as such:from PySide.QtCore import QObject, Signal, Slotfrom functools import partialclass PunchingBag(QObject): ''' Represents a punching bag; when you punch it, it emits a signal that indicates that it was punched. ''' punched = Signal() def __init__(self): # Initialize the PunchingBag as a QObject QObject.__init__(self) def punch(self): ''' Punch the bag ''' self.punched.emit()@Slot()def say_punched(): ''' Give evidence that a bag was punched. ''' print('Bag was punched.')bag = PunchingBag()# Connect the bag's punched signal to the say_punched slotbag.punched.connect(say_punched)for i in range(10): bag.punch()The say_punched() function does not take any parameter, unfortunately. So when the signal is emitted, it can only do whatever is in the function without parameters passed into it. However, using partial, we can make it happen and passed through the string “Bag”. You can see the result here and understand how powerful this could be.from PySide.QtCore import QObject, Signal, Slotfrom functools import partialclass PunchingBag(QObject): ''' Represents a punching bag; when you punch it, it emits a signal that indicates that it was punched. ''' punched = Signal() def __init__(self): # Initialize the PunchingBag as a QObject QObject.__init__(self) def punch(self): ''' Punch the bag ''' self.punched.emit()@Slot()def say_punched(x): ''' Give evidence that a bag was punched. ''' print('%s was punched.' % x)bag = PunchingBag()# Connect the bag's punched signal to the say_punched slotbag.punched.connect(partial(say_punched, 'Bag'))for i in range(10): bag.punch()This now allows me to pass through the string “Bag” to the say_punched() and that could be very useful. Now, you can pass through any other string such as “Purse”, “Pillow” and so on. This is very useful in a particular situation at work where I created a function that performs a generic action for QTableWidget. However, the default connect signal does not allow me to re-use this same function for multiple QTableWidget, leading to duplication of codes. Having the ability to use partial to pass through the appropriate QTableWidget into the generic function discards the need to have such duplicate codes.In the future, I will dwelve more into signals as well." }, { "title": "Basic unit testing", "url": "/posts/basic-unit-test/", "categories": "Python", "tags": "unit test", "date": "2019-04-06 00:00:00 -0700", "snippet": "Today I have begun learning and writing unit tests for some updates I have made to existing python functions. The idea of the unit test is to make sure the updated python modules/functions/classes all produce the same results as before the update. The update is simply swapping existing module usages with new module usages. I am using python’s default unittest module and for now, I am doing test case. Per the definition on python.org, test case is defined as A test case is the smallest unit of testing. It checks for a specific response to a particular set of inputs. unittest provides a base class, TestCase, which may be used to create new test cases.Using the basic example on python.orgimport unittestclass TestStringMethods(unittest.TestCase):That will create an class inheriting the unittest’s TestCase object.import unittestclass TestStringMethods(unittest.TestCase): def test_upper(self): self.assertEqual('foo'.upper(), 'FOO')if __name__ == '__main__': unittest.main()This now adds a function called test_upper that will test whether foo.upper() equals to FOO. That is what assertEqual() does. There are other assert tests such as assertFalse(), assertTrue()… etc as well. It also appears that the test unit functions must start with the name test or it will not work. One thing I have also noticed from running a test like that is that it seems that it will call a form of exit() after completing the test. There is also another way to call the TestStringMethods without usingif __name__ == '__main__': unittest.main()Per the website, we can replace the last two lines with these insteadsuite = unittest.TestLoader().loadTestsFromTestCase(TestStringMethods)unittest.TextTestRunner(verbosity=2).run(suite)Perhaps this method won’t exit out the script editor when finished. That remains to be seen when I test this out further in the near future. Either way, very cool discovery today with unit testing!" }, { "title": "Hello world", "url": "/posts/hello-world/", "categories": "Etc", "tags": "", "date": "2019-04-06 00:00:00 -0700", "snippet": "Hello world! I would like to start posting here on programming topics I am learning as a newly minted software engineer! I hope to make this a nice repository of Python and C++ topics that I have learned along the journey for both myself and whoever may stumble upon this Github Page. On top of programming topics, I hope to also discuss colour science subjects as well in my current role. All in all, lots of topics to discuss so let the fun begin!" } ]
